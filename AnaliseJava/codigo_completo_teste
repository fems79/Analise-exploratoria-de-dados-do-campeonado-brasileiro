import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.geom.AffineTransform;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> new TelaPrincipal().setVisible(true));
    }
}


class Partida {
    private final String mandante;
    private final String visitante;
    private final int golsMandante;
    private final int golsVisitante;

    public Partida(String mandante, String visitante, int golsMandante, int golsVisitante) {
        this.mandante = mandante;
        this.visitante = visitante;
        this.golsMandante = golsMandante;
        this.golsVisitante = golsVisitante;
    }

    public String getMandante() { return mandante; }
    public String getVisitante() { return visitante; }
    public int getGolsMandante() { return golsMandante; }
    public int getGolsVisitante() { return golsVisitante; }

    public int[] getPontos() {
        if (golsMandante > golsVisitante) return new int[]{3, 0};
        else if (golsVisitante > golsMandante) return new int[]{0, 3};
        else return new int[]{1, 1};
    }
}


class Time {
    private final String nome;
    private int pontos = 0;
    private int pontosCasa = 0;
    private int pontosFora = 0;
    private int golsPro = 0;
    private int golsContra = 0;

    public Time(String nome) { this.nome = nome; }
    public String getNome() { return nome; }
    public int getPontos() { return pontos; }
    public int getPontosCasa() { return pontosCasa; }
    public int getPontosFora() { return pontosFora; }
    public int getGolsPro() { return golsPro; }
    public int getGolsContra() { return golsContra; }
    public int getSaldoDeGols() { return golsPro - golsContra; }

    public void atualizar(Partida p) {
        if (p.getMandante().equals(nome)) {
            int pts = p.getPontos()[0];
            pontos += pts;
            pontosCasa += pts;
            golsPro += p.getGolsMandante();
            golsContra += p.getGolsVisitante();
        } else if (p.getVisitante().equals(nome)) {
            int pts = p.getPontos()[1];
            pontos += pts;
            pontosFora += pts;
            golsPro += p.getGolsVisitante();
            golsContra += p.getGolsMandante();
        }
    }
}

class AnalisadorDados {
    public record ResultadoTime(int vitorias, int empates, int derrotas) {}

    public static List<Partida> lerCsv(String caminhoArquivo) throws IOException {
        List<Partida> partidas = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new FileReader(caminhoArquivo))) {
            br.readLine();
            String linha;
            while ((linha = br.readLine()) != null) {
                String[] campos = linha.split(",");
                if (campos.length < 5) continue;
                partidas.add(new Partida(campos[1], campos[2], Integer.parseInt(campos[3]), Integer.parseInt(campos[4])));
            }
        }
        return partidas;
    }

    public static Map<String, Time> gerarTimes(List<Partida> partidas) {
        Map<String, Time> times = new HashMap<>();
        for (Partida p : partidas) {
            times.putIfAbsent(p.getMandante(), new Time(p.getMandante()));
            times.putIfAbsent(p.getVisitante(), new Time(p.getVisitante()));
            times.get(p.getMandante()).atualizar(p);
            times.get(p.getVisitante()).atualizar(p);
        }
        return times;
    }

    public static Map<String, List<Integer>> calcularEvolucaoTodosTimes(List<Partida> todasPartidas) {
        Map<String, List<Integer>> evolucaoGeral = new HashMap<>();
        Map<String, Integer> pontosAtuais = new HashMap<>();
        todasPartidas.stream().flatMap(p -> java.util.stream.Stream.of(p.getMandante(), p.getVisitante())).distinct().forEach(nomeTime -> {
            evolucaoGeral.put(nomeTime, new ArrayList<>());
            pontosAtuais.put(nomeTime, 0);
        });
        for (Partida p : todasPartidas) {
            int[] pontosPartida = p.getPontos();
            int pontosMandante = pontosAtuais.get(p.getMandante()) + pontosPartida[0];
            pontosAtuais.put(p.getMandante(), pontosMandante);
            evolucaoGeral.get(p.getMandante()).add(pontosMandante);
            int pontosVisitante = pontosAtuais.get(p.getVisitante()) + pontosPartida[1];
            pontosAtuais.put(p.getVisitante(), pontosVisitante);
            evolucaoGeral.get(p.getVisitante()).add(pontosVisitante);
        }
        return evolucaoGeral;
    }

    public static ResultadoTime calcularResultados(String nomeTime, List<Partida> todasPartidas) {
        int vitorias = 0, empates = 0, derrotas = 0;
        for (Partida p : todasPartidas) {
            if (p.getMandante().equals(nomeTime) || p.getVisitante().equals(nomeTime)) {
                int[] pontos = p.getPontos();
                boolean ehMandante = p.getMandante().equals(nomeTime);
                if ((ehMandante && pontos[0] == 3) || (!ehMandante && pontos[1] == 3)) vitorias++;
                else if ((ehMandante && pontos[0] == 1) || (!ehMandante && pontos[1] == 1)) empates++;
                else derrotas++;
            }
        }
        return new ResultadoTime(vitorias, empates, derrotas);
    }
}

class PainelGrafico extends JPanel {
    private Map<String, Integer> dados;
    private String tituloGrafico = "Gráfico", tituloEixoY = "Valor";

    public PainelGrafico() {
        this.setPreferredSize(new Dimension(800, 400));
        this.setBackground(Color.WHITE);
    }

    public void setDados(Map<String, Integer> dados, String tituloGrafico, String tituloEixoY) {
        this.tituloGrafico = tituloGrafico;
        this.tituloEixoY = tituloEixoY;
        this.dados = dados.entrySet().stream().sorted(Collections.reverseOrder(Map.Entry.comparingByValue())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));
        int larguraBarra = 50, espacoEntreBarras = 20, margemX = 80;
        int larguraTotal = margemX * 2 + this.dados.size() * larguraBarra + (this.dados.size() - 1) * espacoEntreBarras;
        this.setPreferredSize(new Dimension(larguraTotal, 400));
        revalidate();
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        if (dados == null || dados.isEmpty()) return;
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        int margemX = 80, margemY = 50, alturaDisponivel = getHeight() - 2 * margemY;
        int valorMaximoDados = dados.values().stream().mapToInt(Math::abs).max().orElse(1);
        int limiteEixoY = (int) (Math.ceil(valorMaximoDados / 10.0) * 10);
        if (limiteEixoY == 0) limiteEixoY = 10;
        if (valorMaximoDados > limiteEixoY - (limiteEixoY / 4.0)) limiteEixoY += 10;

        for (int i = 0; i <= 10; i++) {
            int y = getHeight() - margemY - (i * alturaDisponivel) / 10;
            g2.setColor(Color.LIGHT_GRAY);
            g2.drawLine(margemX, y, getWidth() - margemX, y);
            g2.setColor(Color.BLACK);
            g2.drawString(String.valueOf(Math.round(i * (double) limiteEixoY / 10)), margemX - 40, y + 4);
        }
        g2.drawLine(margemX, getHeight() - margemY, margemX, margemY);
        g2.setFont(new Font("Arial", Font.BOLD, 16));
        int larguraTitulo = g2.getFontMetrics().stringWidth(this.tituloGrafico);
        g2.drawString(this.tituloGrafico, (getWidth() - larguraTitulo) / 2, 30);
        AffineTransform oldTransform = g2.getTransform();
        g2.rotate(-Math.PI / 2);
        g2.setFont(new Font("Arial", Font.PLAIN, 12));
        int larguraTituloY = g2.getFontMetrics().stringWidth(this.tituloEixoY);
        g2.drawString(this.tituloEixoY, -((getHeight() + larguraTituloY) / 2), 20);
        g2.setTransform(oldTransform);
        int larguraBarra = 50, espacoEntreBarras = 20, x = margemX + espacoEntreBarras;
        for (Map.Entry<String, Integer> entry : dados.entrySet()) {
            int valor = entry.getValue();
            int alturaBarra = (int) (((double) Math.abs(valor) / limiteEixoY) * alturaDisponivel);
            g2.setColor(valor >= 0 ? Color.decode("#3498db") : Color.RED);
            g2.fillRect(x, getHeight() - margemY - alturaBarra, larguraBarra, alturaBarra);
            g2.setColor(Color.BLACK);
            String nome = entry.getKey();
            int nomeLargura = g2.getFontMetrics().stringWidth(nome);
            g2.drawString(nome, x + larguraBarra / 2 - nomeLargura / 2, getHeight() - margemY + 15);
            g2.drawString(String.valueOf(valor), x + larguraBarra / 2 - 5, getHeight() - margemY - alturaBarra - 5);
            x += larguraBarra + espacoEntreBarras;
        }
    }
}

class PainelPizza extends JPanel {
    private AnalisadorDados.ResultadoTime resultados;
    private String nomeTime;
    private static final Color COR_VITORIA = new Color(34, 139, 34), COR_EMPATE = new Color(255, 215, 0), COR_DERROTA = new Color(220, 20, 60);

    public PainelPizza() {
        this.setBackground(Color.WHITE);
        this.setPreferredSize(new Dimension(800, 600));
    }

    public void setDados(AnalisadorDados.ResultadoTime resultados, String nomeTime) {
        this.resultados = resultados;
        this.nomeTime = nomeTime;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        if (resultados == null) return;
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        int totalJogos = resultados.vitorias() + resultados.empates() + resultados.derrotas();
        if (totalJogos == 0) return;
        int anguloVitorias = (int) Math.round(((double) resultados.vitorias() / totalJogos) * 360);
        int anguloEmpates = (int) Math.round(((double) resultados.empates() / totalJogos) * 360);
        int anguloDerrotas = 360 - anguloVitorias - anguloEmpates;
        int diametro = Math.min(getWidth(), getHeight()) - 100, x = (getWidth() - diametro) / 2, y = (getHeight() - diametro) / 2, anguloInicial = 0;
        g2.setColor(COR_VITORIA);
        g2.fillArc(x, y, diametro, diametro, anguloInicial, anguloVitorias);
        anguloInicial += anguloVitorias;
        g2.setColor(COR_EMPATE);
        g2.fillArc(x, y, diametro, diametro, anguloInicial, anguloEmpates);
        anguloInicial += anguloEmpates;
        g2.setColor(COR_DERROTA);
        g2.fillArc(x, y, diametro, diametro, anguloInicial, anguloDerrotas);
        desenharLegenda(g2, totalJogos);
    }

    private void desenharLegenda(Graphics2D g2, int totalJogos) {
        DecimalFormat df = new DecimalFormat("#.#");
        g2.setFont(new Font("Arial", Font.BOLD, 16));
        g2.setColor(Color.BLACK);
        g2.drawString("Desempenho: " + this.nomeTime, 20, 30);
        g2.setFont(new Font("Arial", Font.PLAIN, 14));
        int yPos = 60;
        g2.setColor(COR_VITORIA);
        g2.fillRect(20, yPos - 10, 15, 15);
        g2.setColor(Color.BLACK);
        g2.drawString(String.format("Vitórias: %d (%s%%)", resultados.vitorias(), df.format((double) resultados.vitorias() / totalJogos * 100)), 45, yPos + 5);
        yPos += 30;
        g2.setColor(COR_EMPATE);
        g2.fillRect(20, yPos - 10, 15, 15);
        g2.setColor(Color.BLACK);
        g2.drawString(String.format("Empates: %d (%s%%)", resultados.empates(), df.format((double) resultados.empates() / totalJogos * 100)), 45, yPos + 5);
        yPos += 30;
        g2.setColor(COR_DERROTA);
        g2.fillRect(20, yPos - 10, 15, 15);
        g2.setColor(Color.BLACK);
        g2.drawString(String.format("Derrotas: %d (%s%%)", resultados.derrotas(), df.format((double) resultados.derrotas() / totalJogos * 100)), 45, yPos + 5);
    }
}

class PainelMultiLinha extends JPanel {
    private Map<String, List<Integer>> dadosEvolucao;
    private Map<String, Color> coresDosTimes;
    private String timeSelecionado = null;
    private final Map<String, Rectangle> legendaBounds;
    private static final int PADDING = 50, LABEL_PADDING = 25, LEGENDA_WIDTH = 150;

    public PainelMultiLinha() {
        this.setBackground(Color.WHITE);
        this.coresDosTimes = new LinkedHashMap<>();
        this.legendaBounds = new LinkedHashMap<>();
        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                String timeClicado = legendaBounds.entrySet().stream().filter(entry -> entry.getValue().contains(e.getPoint())).map(Map.Entry::getKey).findFirst().orElse(null);
                timeSelecionado = (timeClicado != null && timeClicado.equals(timeSelecionado)) ? null : timeClicado;
                repaint();
            }
        });
        addMouseMotionListener(new MouseMotionAdapter() {
            @Override
            public void mouseMoved(MouseEvent e) {
                boolean sobreLegenda = legendaBounds.values().stream().anyMatch(rect -> rect.contains(e.getPoint()));
                setCursor(Cursor.getPredefinedCursor(sobreLegenda ? Cursor.HAND_CURSOR : Cursor.DEFAULT_CURSOR));
            }
        });
    }

    public void setDados(Map<String, List<Integer>> dadosEvolucao) {
        this.dadosEvolucao = dadosEvolucao;
        this.timeSelecionado = null;
        this.legendaBounds.clear();
        this.coresDosTimes.clear();
        int i = 0;
        for (String nomeTime : dadosEvolucao.keySet()) {
            coresDosTimes.put(nomeTime, Color.getHSBColor((float) i / dadosEvolucao.size(), 0.8f, 0.9f));
            i++;
        }
        this.setPreferredSize(new Dimension(1000, 600));
        revalidate();
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        if (dadosEvolucao == null || dadosEvolucao.isEmpty()) return;
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        int maxPontosDados = getMaxPontos();
        int limiteEixoY = (int) (Math.ceil(maxPontosDados / 10.0) * 10);
        if (limiteEixoY == 0) limiteEixoY = 10;
        if (maxPontosDados > limiteEixoY - (limiteEixoY / 4.0)) limiteEixoY += 10;
        desenharEixos(g2, limiteEixoY);
        double xScale = ((double) getWidth() - 2 * PADDING - LABEL_PADDING - LEGENDA_WIDTH) / (getMaxJogos() > 1 ? getMaxJogos() - 1 : 1);
        double yScale = ((double) getHeight() - 2 * PADDING - LABEL_PADDING) / limiteEixoY;
        for (Map.Entry<String, List<Integer>> entry : dadosEvolucao.entrySet()) {
            String nomeTime = entry.getKey();
            List<Integer> pontos = entry.getValue();
            Color corOriginal = coresDosTimes.get(nomeTime);
            if (timeSelecionado == null || nomeTime.equals(timeSelecionado)) {
                g2.setStroke(new BasicStroke(3.5f));
                g2.setColor(corOriginal);
            } else {
                g2.setStroke(new BasicStroke(1.0f));
                g2.setColor(new Color(corOriginal.getRed(), corOriginal.getGreen(), corOriginal.getBlue(), 70));
            }
            for (int i = 0; i < pontos.size() - 1; i++) {
                int x1 = (int) (i * xScale + PADDING + LABEL_PADDING);
                int y1 = getHeight() - PADDING - LABEL_PADDING - (int) (pontos.get(i) * yScale);
                int x2 = (int) ((i + 1) * xScale + PADDING + LABEL_PADDING);
                int y2 = getHeight() - PADDING - LABEL_PADDING - (int) (pontos.get(i + 1) * yScale);
                g2.drawLine(x1, y1, x2, y2);
            }
        }
        desenharLegenda(g2, getWidth() - LEGENDA_WIDTH + 10, PADDING);
    }

    private void desenharEixos(Graphics2D g2, int limiteEixoY) {
        int maxJogos = getMaxJogos();
        for (int i = 0; i <= 10; i++) {
            int y = getHeight() - PADDING - LABEL_PADDING - (i * (getHeight() - 2 * PADDING - LABEL_PADDING)) / 10;
            g2.setColor(Color.LIGHT_GRAY);
            g2.drawLine(PADDING + LABEL_PADDING, y, getWidth() - PADDING - LEGENDA_WIDTH, y);
            g2.setColor(Color.BLACK);
            g2.drawString(String.valueOf((i * limiteEixoY) / 10), PADDING, y + 4);
        }
        double xScale = ((double) getWidth() - 2 * PADDING - LABEL_PADDING - LEGENDA_WIDTH) / (maxJogos > 1 ? maxJogos - 1 : 1);
        for (int i = 0; i < maxJogos; i++) {
            int x = PADDING + LABEL_PADDING + (int) (i * xScale);
            g2.setColor(Color.LIGHT_GRAY);
            g2.drawLine(x, getHeight() - PADDING - LABEL_PADDING, x, PADDING);
            g2.setColor(Color.BLACK);
            g2.drawString(String.valueOf(i + 1), x - 3, getHeight() - PADDING - LABEL_PADDING + 20);
        }
        g2.setColor(Color.BLACK);
        g2.drawLine(PADDING + LABEL_PADDING, getHeight() - PADDING - LABEL_PADDING, PADDING + LABEL_PADDING, PADDING);
        g2.drawLine(PADDING + LABEL_PADDING, getHeight() - PADDING - LABEL_PADDING, getWidth() - PADDING - LEGENDA_WIDTH, getHeight() - PADDING - LABEL_PADDING);
        g2.setFont(new Font("Arial", Font.PLAIN, 12));
        String tituloX = "Jogos Disputados";
        int larguraTituloX = g2.getFontMetrics().stringWidth(tituloX);
        g2.drawString(tituloX, (getWidth() - LEGENDA_WIDTH - larguraTituloX) / 2, getHeight() - 15);
        AffineTransform oldTransform = g2.getTransform();
        g2.rotate(-Math.PI / 2);
        String tituloY = "Pontos Acumulados";
        int larguraTituloY = g2.getFontMetrics().stringWidth(tituloY);
        g2.drawString(tituloY, -((getHeight() + larguraTituloY) / 2), 20);
        g2.setTransform(oldTransform);
    }

    private void desenharLegenda(Graphics2D g2, int x, int y) {
        legendaBounds.clear();
        g2.setFont(new Font("Arial", Font.BOLD, 12));
        g2.setColor(Color.BLACK);
        g2.drawString("Legenda", x, y - 15);
        g2.setFont(new Font("Arial", Font.ITALIC, 10));
        g2.setColor(Color.DARK_GRAY);
        g2.drawString("(Clique para destacar)", x, y);
        g2.setFont(new Font("Arial", Font.PLAIN, 11));
        List<String> nomesTimes = new ArrayList<>(dadosEvolucao.keySet());
        Collections.sort(nomesTimes);
        int i = 0;
        int yOffset = y + 15;
        for (String nomeTime : nomesTimes) {
            int yPos = yOffset + (i * 15);
            Color corTime = coresDosTimes.get(nomeTime);
            g2.setColor(corTime);
            g2.fillRect(x, yPos, 10, 10);
            g2.setColor(Color.BLACK);
            if (nomeTime.equals(timeSelecionado)) g2.setFont(g2.getFont().deriveFont(Font.BOLD));
            g2.drawString(nomeTime, x + 15, yPos + 10);
            g2.setFont(g2.getFont().deriveFont(Font.PLAIN));
            legendaBounds.put(nomeTime, new Rectangle(x, yPos, LEGENDA_WIDTH, 12));
            i++;
        }
    }

    private int getMaxPontos() { return dadosEvolucao == null ? 0 : dadosEvolucao.values().stream().flatMap(List::stream).mapToInt(v -> v).max().orElse(0); }
    private int getMaxJogos() { return dadosEvolucao == null ? 0 : dadosEvolucao.values().stream().mapToInt(List::size).max().orElse(0); }
}

class TelaPrincipal extends JFrame {
    private final PainelGrafico painelGraficoBarras;
    private final PainelMultiLinha painelGraficoMultiLinha;
    private final PainelPizza painelGraficoPizza;
    private Map<String, Time> times;
    private List<Partida> partidas;

    public TelaPrincipal() {
        setTitle("Análise do Campeonato Brasileiro");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(850, 600);
        setLayout(new BorderLayout());
        JPanel painelControles = new JPanel();
        JButton btnCarregar = new JButton("Carregar CSV");
        painelControles.add(btnCarregar);
        add(painelControles, BorderLayout.NORTH);
        JTabbedPane abas = new JTabbedPane();
        JPanel abaClassificacao = new JPanel(new BorderLayout());
        JComboBox<String> comboAnalise = new JComboBox<>(new String[]{"Classificacao Geral", "Classificacao Mandante", "Classificacao Visitante", "Classificacao Gols-Pro", "Classificacao Gols Contra", "Classificacao Saldo de Gols"});
        abaClassificacao.add(comboAnalise, BorderLayout.NORTH);
        painelGraficoBarras = new PainelGrafico();
        abaClassificacao.add(new JScrollPane(painelGraficoBarras), BorderLayout.CENTER);
        abas.addTab("Classificação Geral", abaClassificacao);
        painelGraficoMultiLinha = new PainelMultiLinha();
        abas.addTab("Comparativo de Evolução", new JScrollPane(painelGraficoMultiLinha));
        JPanel abaPizza = new JPanel(new BorderLayout());
        JPanel painelSelecaoTimePizza = new JPanel();
        painelSelecaoTimePizza.add(new JLabel("Selecione o Time:"));
        JComboBox<String> comboTimesPizza = new JComboBox<>();
        comboTimesPizza.setEnabled(false);
        painelSelecaoTimePizza.add(comboTimesPizza);
        abaPizza.add(painelSelecaoTimePizza, BorderLayout.NORTH);
        painelGraficoPizza = new PainelPizza();
        abaPizza.add(painelGraficoPizza, BorderLayout.CENTER);
        abas.addTab("Desempenho por Time", abaPizza);
        add(abas, BorderLayout.CENTER);
        btnCarregar.addActionListener(e -> carregarDados(comboAnalise, comboTimesPizza));
        comboAnalise.addActionListener(e -> {
            if (partidas != null) atualizarGraficoBarras(comboAnalise.getSelectedItem().toString());
        });
        comboTimesPizza.addActionListener(e -> {
            if (comboTimesPizza.getSelectedItem() != null) atualizarGraficoPizza(comboTimesPizza.getSelectedItem().toString());
        });
        setLocationRelativeTo(null);
    }

    private void carregarDados(JComboBox<String> comboAnalise, JComboBox<String> comboTimesPizza) {
        JFileChooser seletor = new JFileChooser();
        if (seletor.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            try {
                partidas = AnalisadorDados.lerCsv(seletor.getSelectedFile().getAbsolutePath());
                times = AnalisadorDados.gerarTimes(partidas);
                atualizarGraficoBarras(comboAnalise.getSelectedItem().toString());
                Map<String, List<Integer>> evolucaoGeral = AnalisadorDados.calcularEvolucaoTodosTimes(partidas);
                painelGraficoMultiLinha.setDados(evolucaoGeral);
                comboTimesPizza.removeAllItems();
                List<String> nomesDosTimes = times.keySet().stream().sorted().collect(Collectors.toList());
                nomesDosTimes.forEach(comboTimesPizza::addItem);
                comboTimesPizza.setEnabled(true);
                if (!nomesDosTimes.isEmpty()) atualizarGraficoPizza(nomesDosTimes.get(0));
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(this, "Erro ao carregar ou processar o arquivo: " + ex.getMessage(), "Erro de Arquivo", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    private void atualizarGraficoBarras(String tipo) {
        if (times == null) return;
        Function<Time, Integer> func;
        switch (tipo) {
            case "Classificacao Geral" -> func = Time::getPontos;
            case "Classificacao Mandante" -> func = Time::getPontosCasa;
            case "Classificacao Visitante" -> func = Time::getPontosFora;
            case "Classificacao Gols-Pro" -> func = Time::getGolsPro;
            case "Classificacao Gols Contra" -> func = Time::getGolsContra;
            case "Classificacao Saldo de Gols" -> func = Time::getSaldoDeGols;
            default -> func = t -> 0;
        }
        String tituloEixoY;
        if (tipo.contains("Gols")) tituloEixoY = "Gols";
        else if (tipo.contains("Saldo")) tituloEixoY = "Saldo de Gols";
        else tituloEixoY = "Pontos";
        Map<String, Integer> dadosGrafico = new HashMap<>();
        for (Time t : times.values()) dadosGrafico.put(t.getNome(), func.apply(t));
        painelGraficoBarras.setDados(dadosGrafico, tipo, tituloEixoY);
    }

    private void atualizarGraficoPizza(String nomeTime) {
        if (partidas == null || nomeTime == null) return;
        AnalisadorDados.ResultadoTime resultados = AnalisadorDados.calcularResultados(nomeTime, partidas);
        painelGraficoPizza.setDados(resultados, nomeTime);
    }
}
public class Main {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> new TelaPrincipal().setVisible(true));
    }
}
